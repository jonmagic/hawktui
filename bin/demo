#!/usr/bin/env ruby

require "bundler/setup"
require "faker"
require "hawktui/streaming_table"

def padded_string(str, len, padding: "0", string_color: 7, padding_color: 7)
  str = str.to_s
  padding_size = [len - str.length, 0].max
  [
    { value: (padding.to_s * padding_size), color: padding_color },
    { value: str, color: string_color },
  ]
end

# Function to generate a username and email address
def username_and_email_generator(name)
  if name.nil?
    username = Faker::Internet.username
    email = Faker::Internet.email
  else
    separator = ["_", "-", ".", ""].sample
    username = name.gsub(".", "").split(" ").join(separator)
    email_domain = ["gmail.com", "outlook.com", "hotmail.com", Faker::Internet.domain_name].sample
    email = username + "@" + email_domain
    if rand < 0.5
      username = username.downcase
      email = email.downcase
    end
  end

  [username, email]
end

# Function to generate consistent or mismatched data
def generate_row(id)
  consistent = rand < 0.8 # 80% chance for consistent data
  name = Faker::Name.name if consistent
  username, email = username_and_email_generator(name)

  {
    "ID" => padded_string(id, 9, padding: "0", string_color: 244, padding_color: 239),
    "Username" => {
      value: username,
      color: 244,
    },
    "Email Address" => {
      value: email,
      color: 7,
    },
    "Full Name" => {
      value: name || Faker::Name.name,
      color: 7,
    },
    "Age" => {
      value: Faker::Number.between(from: 18, to: 84).to_s,
      color: 7,
    },
    "Timestamp" => {
      value: Time.now.strftime("%Y-%m-%d %H:%M:%S"),
      color: 244,
    },
  }
end

# Initial state
initial_state = {
  multi_select: false, # Whether multi-select mode is active
  multi_select_direction: nil, # :up or :down (the most recent direction of multi-select scrolling)
  multi_select_start_index: nil, # The row index where multi-select began
}

# Keybindings for the UI
keybindings = {
  # Toggle selection on the current row (single-row toggle)
  " " => ->(ui) {
    ui.toggle_selection
  },
  # Toggle multi-select mode
  "m" => ->(ui) {
    ui.state[:multi_select] = !ui.state[:multi_select]

    if ui.state[:multi_select]
      # We're enabling multi-select:
      # 1) Mark the start index
      ui.state[:multi_select_start_index] = ui.current_row_index
      # 2) Reset the direction so next move sets it
      ui.state[:multi_select_direction] = nil
      # 3) Select the current row right away
      ui.toggle_selection
    else
      # We're disabling multi-select:
      # 1) Clear the start index
      ui.state[:multi_select_start_index] = nil
      # 2) Reset direction
      ui.state[:multi_select_direction] = nil
    end
  },
  # Move DOWN
  "KEY_DOWN" => ->(ui) {
    ui.toggle_pause unless ui.paused

    if ui.state[:multi_select]
      # If the last direction was 'up' but now we're going 'down', unselect current row (unless it's the start index)
      if ui.state[:multi_select_direction] == :up && ui.current_row_index != ui.state[:multi_select_start_index]
        ui.toggle_selection  # toggles OFF the current row
      end

      # Move down
      ui.navigate_down

      # Now toggle ON the new current row (unless it’s the start index you already have selected)
      if ui.current_row_index != ui.state[:multi_select_start_index]
        ui.toggle_selection
      end

      # Update direction
      ui.state[:multi_select_direction] = :down
    else
      ui.navigate_down
    end
  },
  # Move UP
  Curses::KEY_UP => ->(ui) {
    if ui.state[:multi_select]
      # If the last direction was 'down' but now we're going 'up', unselect current row (unless it's the start index)
      if ui.state[:multi_select_direction] == :down && ui.current_row_index != ui.state[:multi_select_start_index]
        ui.toggle_selection  # toggles OFF the current row
      end

      # Move up
      ui.navigate_up

      # Now toggle ON the new current row (unless it’s the start index you already have selected)
      if ui.current_row_index != ui.state[:multi_select_start_index]
        ui.toggle_selection
      end

      # Update direction
      ui.state[:multi_select_direction] = :up
    else
      ui.navigate_up
    end
  },
  # Move down a page
  Curses::KEY_NPAGE => ->(ui) {
    ui.toggle_pause unless ui.paused
    ui.navigate_page_down
  },
  # Move up a page
  Curses::KEY_PPAGE => ->(ui) {ui.navigate_page_up },
  # Clear all selections
  "r" => ->(ui) {
    ui.clear_selections
  },
  # Pause/unpause
  "p" => ->(ui) { ui.toggle_pause },
  # Quit
  "q" => ->(ui) { ui.stop },
}

# Initialize the table
table = Hawktui::StreamingTable.new(keybindings: keybindings, state: initial_state)
table.setup
table.layout = Hawktui::StreamingTable::Layout.new(columns: [
  { name: "ID", width: 9 },
  { name: "Username", width: 21 },
  { name: "Email Address", width: 40 },
  { name: "Full Name", width: Curses.cols - 100 },
  { name: "Age", width: 3 },
  { name: "Timestamp", width: 20 }
])

# Ensure cleanup at exit
at_exit do
  table.stop if table
end

# Handle signals
Signal.trap("INT") { exit }
Signal.trap("TERM") { exit }

# Background thread to generate rows
row_generator = Thread.new do
  id = 1

  loop do
    break if table.should_exit

    unless table.paused
      # Generate a row of data
      row_data = generate_row(id)

      # Add row to the table
      table.add_row(row_data)

      # Increment the ID
      id += 1
    end

    # Respect the `paused` attribute
    sleep 0.1 while table.paused

    # Pause between new rows
    sleep 0.4
  end
end

# Start the table UI
table.start

# Main loop to check for exit condition
loop do
  if table.should_exit
    row_generator.exit
    exit
  end
  sleep 0.1
end

# Wait for the row generator to finish
row_generator.join
